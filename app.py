"""Aplica√ß√£o Flask para orquestrar as etapas de gera√ß√£o de v√≠deos."""

from flask import (
    Flask,
    render_template,
    request,
    redirect,
    url_for,
    jsonify,
    send_from_directory,
    send_file,
    Response,
    stream_with_context,
)
import tkinter as tk
from tkinter import filedialog
import re, os, json, asyncio, time, subprocess, threading, sys, glob

from werkzeug.utils import secure_filename

from modules.config import salvar_config, carregar_config, get_config
from modules.parser_prompts import parse_prompts_txt, salvar_prompt_txt
from modules.gerar_narracao import iniciar_driver, login, gerar_e_baixar
from modules.gerar_ASS import gerar_ass_com_whisper, carregar_modelo
from modules.gerar_SRT import gerar_srt_com_bloco
from modules.paths import get_paths
from modules.juntar_cenas import (
    montar_uma_cena,
    adicionar_trilha_sonora,
    adicionar_marca_dagua,
    unir_cenas_com_transicoes,
)
from modules.verify_license import verify_license
from modules.licenca import (
    get_creditos,
    carregar_config_licenciada,
    salvar_config_licenciada,
    carregar_fernet,
)
from modules.remover_silencio import remover_silencios

from blueprints.imagens import imagens_bp

path = get_paths()  # ‚Üê cria o dicion√°rio de caminhos ao iniciar o app



estado_pausa = {
    "pausado": False,
    "cond": threading.Condition()
}

app = Flask(__name__)
app.config['USUARIO_CONFIG'] = carregar_config()
app.register_blueprint(imagens_bp)

@app.route("/")
def index():
    """Renderiza a p√°gina inicial da aplica√ß√£o.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: P√°gina inicial com o template de gera√ß√£o de prompt.
    """
    return render_template("generate_prompt.html", page_title="In√≠cio")

#----- Novo prompt ----------------------------------------------------------------------------------------------------

@app.route("/generate_prompt", methods=["GET"])
def prompt_page():
    """Exibe a p√°gina respons√°vel por solicitar a gera√ß√£o de prompts.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: Template HTML com o formul√°rio de prompts.
    """

    return render_template("generate_prompt.html",
                           page_title="Gerar Prompt")

@app.route("/processar_prompt", methods=["POST"])
def processar_prompt():
    """Processa o prompt enviado pelo usu√°rio e gera os arquivos iniciais.

    Par√¢metros:
        Nenhum: os dados s√£o extra√≠dos do corpo JSON da requisi√ß√£o.

    Retorna:
        flask.Response: Resposta JSON indicando sucesso ou o motivo do erro.
    """
    try:
        data = request.get_json()
        prompt = data.get("prompt", "").strip()
        nome_video = data.get("nome_video", "").strip()

        if not prompt:
            return jsonify({"status": "erro", "error": "Prompt vazio."}), 400

        if not nome_video:
            return jsonify({"status": "erro", "error": "Nome do v√≠deo n√£o informado."}), 400

        # ‚úÖ Corre√ß√µes autom√°ticas
        prompt_corrigido = re.sub(r"\bimagem\b", "Imagem", prompt, flags=re.IGNORECASE)
        prompt_corrigido = re.sub(r"\bnar+a√ß√£o\b", "Narra√ß√£o", prompt_corrigido, flags=re.IGNORECASE)
        prompt_corrigido = re.sub(r"\banima+√ß√£o\b", "Anima√ß√£o", prompt_corrigido, flags=re.IGNORECASE)
        prompt_corrigido = re.sub(r"\btrilha sonora\b", "Trilha Sonora", prompt_corrigido, flags=re.IGNORECASE)

        # ‚úÖ Garante separadores ---
        blocos = [b.strip() for b in prompt_corrigido.split("---") if b.strip()]
        prompt_formatado = "\n\n---\n\n".join(blocos)

        # ‚úÖ Salvar no prompts.txt
        salvar_prompt_txt(prompt_formatado)

        # ‚úÖ Gerar cenas.json
        cenas = parse_prompts_txt()

        for cena in cenas:
            if "narracao" in cena and "legenda" not in cena:
                cena["legenda"] = cena["narracao"]



        # Salva o cenas.json
        with open(path["cenas"], "w", encoding="utf-8") as f:
            json.dump(cenas, f, ensure_ascii=False, indent=4)

        # Salvar nome do v√≠deo
        with open(path["nome_video"], "w", encoding="utf-8") as f:
            f.write(nome_video)
        limpar_pastas_saida()
        return jsonify({"status": "ok"})

    except Exception as e:
        return jsonify({"status": "erro", "error": str(e)}), 500

#----------------------------------------------------------------------------------------------------------------------

@app.route("/api/creditos")
def api_creditos():
    """Exp√µe o total de cr√©ditos dispon√≠veis para o usu√°rio.

    Par√¢metros:
        Nenhum.

    Retorna:
        dict: Quantidade atual de cr√©ditos.
    """

    return {"creditos": get_creditos()}


#----------------------------------------------------------------------------------------------------------------------

#----- NARRA√á√ÉO -------------------------------------------------------------------------------------------------------

@app.route("/generate_narracao")
def generate_narracao():
    """Exibe a interface de gera√ß√£o de narra√ß√µes para as cenas dispon√≠veis.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: P√°gina HTML com a lista de cenas e op√ß√µes de narra√ß√£o.
    """
    #path = os.path.join(os.getcwd(),"cenas.json")
    if not os.path.exists(path["cenas"]):
        return "Arquivo cenas.json n√£o encontrado", 500
    with open(path["cenas"], "r", encoding="utf-8") as f:
        cenas = json.load(f)
    return render_template("generate_narracao.html",page_title="Gerar Narra√ß√£o", cenas=cenas)
# @app.route("/narracoes", methods=["POST"])
# def narracoes_run():
#     """Gera narra√ß√µes para as cenas selecionadas."""
#     scope  = request.form.get("scope", "all")
#     single = request.form.get("single_index", type=int)
#     start  = request.form.get("from_index", type=int)
#     custom = request.form.get("custom_indices", "")
#     voz    = request.form.get("voz", "Brian")
#     fonte  = request.form.get("fonte", "elevenlabs")
#
#     path = gerar_narracao.get_paths()["cenas"]
#     with open(path, encoding="utf-8") as f:
#         total = len(json.load(f))
#
#     # Definir os √≠ndices com base no escopo
#     if scope == "custom" and custom:
#         try:
#             indices = [int(i.strip()) - 1 for i in custom.split(",") if i.strip().isdigit()]
#             indices = [i for i in indices if 0 <= i < total]
#         except:
#             return jsonify({"error": "√çndices inv√°lidos."}), 400
#     elif scope == "all":
#         indices = list(range(total))
#     elif scope == "single" and single and 1 <= single <= total:
#         indices = [single - 1]
#     elif scope == "from" and start and 1 <= start <= total:
#         indices = list(range(start - 1, total))
#     else:
#         return jsonify({"error": "Par√¢metros inv√°lidos"}), 400
#
#     try:
#         resultado = run_gerar_narracoes(indices, voz=voz, fonte=fonte)
#     except Exception as e:
#         return jsonify({"error": str(e)}), 500
#
#     return jsonify({
#         "status": "ok",
#         "logs": resultado["logs"],
#         "cenas": resultado["cenas"]
#     })
@app.route("/narracao_stream", methods=["GET"])
def gerar_narracoes_stream():
    """Gera narra√ß√µes com retorno cont√≠nuo via Server-Sent Events.

    Par√¢metros:
        Nenhum: os filtros s√£o obtidos dos par√¢metros de consulta.

    Retorna:
        flask.Response: Stream com mensagens de progresso do processamento.
    """
    scope   = request.args.get("scope", "all")
    single  = request.args.get("single_index", type=int)
    start   = request.args.get("from_index", type=int)
    custom  = request.args.get("custom_indices", "")
    voz     = request.args.get("voz", "Brian")
    fonte   = request.args.get("fonte", "elevenlabs")

    # path = gerar_narracao.get_paths()["cenas"]
    with open(path["cenas"], encoding="utf-8") as f:
        total = len(json.load(f))

    if scope == "custom" and custom:
        try:
            indices = [int(i.strip()) - 1 for i in custom.split(",") if i.strip().isdigit()]
            indices = [i for i in indices if 0 <= i < total]
        except:
            return Response("data: ‚ùå √çndices personalizados inv√°lidos\n\n", mimetype='text/event-stream')
    elif scope == "all":
        indices = list(range(total))
    elif scope == "single" and single and 1 <= single <= total:
        indices = [single - 1]
    elif scope == "from" and start and 1 <= start <= total:
        indices = list(range(start - 1, total))
    else:
        return Response("data: ‚ùå Par√¢metros inv√°lidos\n\n", mimetype='text/event-stream')

    def gerar_eventos():
        """Produz eventos em tempo real conforme cada narra√ß√£o √© conclu√≠da.

        Par√¢metros:
            Nenhum.

        Retorna:
            Generator[str, None, None]: Mensagens formatadas para SSE.
        """
        with open(path["cenas"], encoding="utf-8") as f:
            cenas = json.load(f)

        yield f"data: üöÄ Iniciando gera√ß√£o de narra√ß√µes...\n\n"
        driver = iniciar_driver()
        try:
            login(driver, voz=voz)
            #--------------confirmar se a pausa √© aqui----------------
            if estado_pausa["pausado"]:
                yield f"data: ‚è∏Ô∏è Pausado . Aguarde libera√ß√£o do usu√°rio.\n\n"
                with estado_pausa["cond"]:
                    estado_pausa["cond"].wait()

            for i in indices:
                texto = cenas[i].get("narracao")
                if not texto:
                    yield f"data: ‚ö†Ô∏è Cena {i+1} sem texto.\n\n"
                    continue

                yield f"data: üéôÔ∏è Gerando narra√ß√£o {i+1}\n\n"
                path_audio = gerar_e_baixar(driver, texto, i)
                cenas[i]["audio_path"] = path_audio
                yield f"data: ‚úÖ Narra√ß√£o {i+1} salva\n\n"

                with open(path["cenas"], "w", encoding="utf-8") as f:
                    json.dump(cenas, f, ensure_ascii=False, indent=2)

                time.sleep(0.2)
        finally:
            driver.quit()

        yield f"data: üîö Fim do processo\n\n"

    return Response(stream_with_context(gerar_eventos()), mimetype='text/event-stream')

@app.route("/modules/audio/<path:filename>")
def serve_module_audio(filename):
    """Entrega arquivos de √°udio gerados pela aplica√ß√£o.

    Par√¢metros:
        filename (str): Nome do arquivo localizado na pasta de √°udios.

    Retorna:
        flask.Response: Resposta de envio do arquivo solicitado.
    """
    pasta = get_paths()["audios"]
    return send_from_directory(path["audios"], filename)

@app.route("/editar_narracao", methods=["POST"])
def editar_narracao():
    """Atualiza o texto de narra√ß√£o de uma cena espec√≠fica.

    Par√¢metros:
        Nenhum: o √≠ndice e o novo texto s√£o obtidos do corpo JSON.

    Retorna:
        flask.Response: Resultado em JSON indicando o sucesso da opera√ß√£o.
    """
    data = request.get_json()
    #print("üö® Dados recebidos:", data)  # üëà Adicione isso
    index = int(data["index"])
    novo = data["novo_texto"]

    #paths = gerar_narracao.get_paths()
    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    cenas[index]["narracao"] = novo

    with open(path["cenas"], "w", encoding="utf-8") as f:
        json.dump(cenas, f, ensure_ascii=False, indent=2)

    return jsonify({"status": "ok"})

@app.route("/get_narracao")
def get_narracao():
    """Recupera o texto da narra√ß√£o associado a uma cena.

    Par√¢metros:
        Nenhum: o √≠ndice √© lido dos par√¢metros da requisi√ß√£o.

    Retorna:
        flask.Response: Conte√∫do JSON contendo o texto da narra√ß√£o.
    """
    index = int(request.args.get("index", 0))

    #paths = gerar_narracao.get_paths()

    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    texto = cenas[index].get("narracao", "")
    return jsonify({"texto": texto})

@app.route("/remover_silencio")
def remover_silencio_route():
    """Remove sil√™ncios dos √°udios de narra√ß√£o via endpoint HTTP.

    Par√¢metros:
        Nenhum: o tempo m√≠nimo de sil√™ncio √© fornecido como query string.

    Retorna:
        flask.Response: Resultado JSON com logs ou mensagem de erro.
    """
    try:
        min_silence = float(request.args.get("min_silence", "0.3"))
    except ValueError:
        return jsonify({"status": "erro", "error": "Par√¢metro min_silence inv√°lido."}), 400

    resultado = remover_silencios(min_silence=min_silence)

    if resultado.get("status") == "erro":
        return jsonify(resultado), 400

    return jsonify(resultado)

@app.route("/ativar_pausa", methods=["POST"])
def ativar_pausa():
    """Ativa o estado de pausa para interromper a gera√ß√£o de narra√ß√µes.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: Resposta JSON confirmando a altera√ß√£o do estado.
    """
    with estado_pausa["cond"]:
        estado_pausa["pausado"] = True
    return jsonify({"status": "ok"})

@app.route("/continuar_narracao", methods=["POST"])
def continuar_narracao():
    """Retoma a gera√ß√£o de narra√ß√µes previamente pausada.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: Resposta JSON confirmando a retomada do processo.
    """
    with estado_pausa["cond"]:
        estado_pausa["pausado"] = False
        estado_pausa["cond"].notify()
    return jsonify({"status": "ok"})

#---------------------------------------------------------------------------------------------------------------------

#----- LEGENDAS (vers√£o .ASS) ---------------------------------------------------------------------------------------

@app.route("/generate_legenda")
def generate_legenda():
    """Exibe a interface para gera√ß√£o de legendas das narra√ß√µes.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: P√°gina HTML com a listagem de cenas e op√ß√µes de legenda.
    """
    #path = os.path.join(os.getcwd(),"cenas.json")

    with open(path["cenas"], "r", encoding="utf-8") as f:
        cenas = json.load(f)

    return render_template("generate_legenda.html", page_title="Gerar Legendas", cenas=cenas)

@app.route("/legendas_ass", methods=["POST"])
def gerar_legendas_ass():
    """Gera arquivos .ASS estilizados para as cenas selecionadas.

    Par√¢metros:
        Nenhum: a sele√ß√£o e o estilo s√£o recebidos no corpo JSON.

    Retorna:
        flask.Response: Resposta JSON com logs e dados atualizados das cenas.
    """
    data = request.get_json()
    scope  = data.get("scope", "all")
    single = data.get("single_index")
    start  = data.get("from_index")

    estilo={
        "fonte": data.get("fonte", "Arial"),
        "tamanho": int(data.get("tamanho", 48)),
        "estilo": data.get("estilo", "simples"),
        "animacao": data.get("animacao", "nenhuma"),
        "cor_primaria": data.get("cor_primaria"),
        "cor_secundaria": data.get("cor_secundaria", "#00FFFF"),
        "cor_outline": data.get("cor_outline", "#000000"),
        "cor_back": data.get("cor_back", "#000000")  # mesmo campo usado
    }

    #path=gerar_ASS.get_paths()

    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    total = len(cenas)
    if scope == "all":
        indices = list(range(total))
    elif scope == "single" and single and 1 <= single <= total:
        indices = [single - 1]
    elif scope == "from" and start and 1 <= start <= total:
        indices = list(range(start - 1, total))
    else:
        return jsonify({"error": "Par√¢metros inv√°lidos"}), 400

    logs = []
    modelo = carregar_modelo()
    modo = data.get("modo", "linha2")  # ‚Üê CORRE√á√ÉO AQUI

    try:
        #paths = gerar_ASS.get_paths()
        for idx in indices:
            path_audio = os.path.join(path["audios"], f"narracao{idx+1}.mp3")
            path_ass   = os.path.join(path["legendas_ass"], f"legenda{idx+1}.ass")

            if not os.path.exists(path_audio):
                logs.append(f"‚ö†Ô∏è √Åudio {idx + 1} n√£o encontrado")
                continue

            logs.append(f"üìù Gerando legenda {idx + 1}")
            gerar_ass_com_whisper(modelo, path_audio, path_ass, estilo, modo)  # ‚Üê CORRE√á√ÉO AQUI
            cenas[idx]["ass_path"] = path_ass
            logs.append(f"‚úÖ Legenda {idx + 1} salva: {path_ass}")

        with open(path["cenas"], "w", encoding="utf-8") as f:
            json.dump(cenas, f, ensure_ascii=False, indent=2)

    except Exception as e:
        return jsonify({"error": str(e)}), 500

    return jsonify({"status": "ok", "logs": logs, "cenas": cenas})

@app.route("/legendas_srt", methods=["POST"])
def gerar_legendas_srt():
    """Gera legendas no formato SRT conforme os par√¢metros enviados.

    Par√¢metros:
        Nenhum: escopo e configura√ß√µes s√£o lidos do corpo JSON.

    Retorna:
        flask.Response: Resposta JSON com logs do processamento.
    """
    data = request.get_json()
    scope = data.get("scope", "all")
    qtde_palavras = int(data.get("qtde_palavras", 4))

    single = data.get("single_index")
    start = data.get("from_index")

    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    if scope == "single" and single is not None:
        indices = [single]
    elif scope == "from" and start is not None:
        indices = list(range(start, len(cenas)+1))
    else:
        indices = list(range(1, len(cenas)+1))

    print("Quantidade de cenas: ", len(cenas))
    print("Quantidade de indices: ", indices)
    resultado = gerar_srt_com_bloco(indices, qtde_palavras)
    return jsonify({"status": "ok", "logs": resultado})

@app.route("/get_legenda")
def get_legenda():
    """Retorna o texto de legenda associado a uma cena espec√≠fica.

    Par√¢metros:
        Nenhum: o √≠ndice desejado √© informado na query string.

    Retorna:
        flask.Response: JSON com o texto de legenda ou narra√ß√£o.
    """
    index = int(request.args.get("index", 0))
    #paths = gerar_ASS.get_paths()

    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    texto = cenas[index].get("legenda") or cenas[index].get("narracao", "")
    return jsonify({"texto": texto})

@app.route("/editar_legenda", methods=["POST"])
def editar_legenda():
    """Atualiza o conte√∫do de legenda de uma cena espec√≠fica.

    Par√¢metros:
        Nenhum: recebe √≠ndice e texto pelo corpo JSON.

    Retorna:
        flask.Response: Resposta JSON sinalizando sucesso da atualiza√ß√£o.
    """
    data = request.get_json()
    index = int(data["index"])
    novo = data["novo_texto"]


    #paths = gerar_ASS.get_paths()
    with open(path["cenas"], encoding="utf-8") as f:
        cenas = json.load(f)

    cenas[index]["legenda"] = novo

    with open(path["cenas"], "w", encoding="utf-8") as f:
        json.dump(cenas, f, ensure_ascii=False, indent=2)

    return jsonify({"status": "ok"})

@app.route("/verificar_legendas_ass")
def verificar_legendas_ass():
    """Verifica se h√° arquivos de legendas ASS gerados.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: JSON indicando a exist√™ncia de arquivos na pasta.
    """
    legenda_dir = get_paths()["legendas_ass"]
    arquivos = glob(os.path.join(legenda_dir, "*.ass"))
    return jsonify({"tem": bool(arquivos)})


#---------------------------------------------------------------------------------------------------------------------

@app.route("/generate_final")
def generate_final():
    path = caminho_cenas_final()
    if not os.path.exists(path):
        return "Arquivo cenas_com_imagens.json n√£o encontrado", 500
    try:
        with open(path, "r", encoding="utf-8") as f:
            cenas = json.load(f)
        return render_template("generate_final.html", page_title="Gerar Video Final", cenas=cenas)
    except json.JSONDecodeError:
        return "Erro ao ler o arquivo JSON de cenas", 500

@app.route("/montar_cenas_stream", methods=["GET"])
def montar_cenas_stream():
    scope   = request.args.get("scope", "all")
    single  = request.args.get("single_index", type=int)
    start   = request.args.get("from_index", type=int)
    print(f"üì• scope={scope} | single={single} | from={start}")
    #path = caminho_cenas_final()
    with open(path["cenas_com_imagens"], encoding="utf-8") as f:
        cenas_json = json.load(f)
        total = len(cenas_json)

    print("o cenas json esta em: ", path["cenas"])
    print(cenas_json)
    print(f"üì• scope={scope} | single={single} | from={start}")
    if scope == "all":
        indices = list(range(total))
    elif scope == "single" and single and 1 <= single <= total:
        indices = [single - 1]
    elif scope == "from" and start and 1 <= start <= total:
        indices = list(range(start - 1, total))
    else:
        return Response("data: ‚ùå Par√¢metros inv√°lidos\n\n", mimetype='text/event-stream')

    def gerar():
        yield "data: üöÄ Iniciando gera√ß√£o das cenas individuais...\n\n"
        logs = []
        for idx in indices:
            try:
                config = cenas_json[idx]
                print(cenas_json)
                print(cenas_json[idx])


                caminho = montar_uma_cena(idx, config)
                print("chegou aqui")
                logs.append(f"‚úÖ Cena {idx + 1} salva em {os.path.basename(caminho)}")
                yield f"data: ‚úÖ Cena {idx + 1} gerada com sucesso\n\n"
            except Exception as e:
                logs.append(f"‚ùå Erro na cena {idx + 1}: {str(e)}")
                yield f"data: ‚ùå Erro na cena {idx + 1}: {str(e)}\n\n"
                yield f"data: ‚ö†Ô∏è Config usada: {json.dumps(cenas_json[idx], indent=2)}\n\n"
        yield "data: üîö Conclus√£o das cenas\n\n"

    return Response(stream_with_context(gerar()), mimetype='text/event-stream')

@app.route("/atualizar_config_cenas", methods=["POST"])
def atualizar_config_cenas():
    cenas_config = request.get_json()
    #path = caminho_cenas_final()
    with open(path["cenas_com_imagens"], encoding="utf-8") as f:
        cenas_existentes = json.load(f)

    for i, cena in enumerate(cenas_config):
        cenas_existentes[i].update(cena)

    with open(path["cenas_com_imagens"], "w", encoding="utf-8") as f:
        json.dump(cenas_existentes, f, indent=2, ensure_ascii=False)

    return jsonify({"status": "ok"})

@app.route("/finalizar_stream", methods=["POST"])
def finalizar_stream():
    """Unifica cenas e aplica p√≥s-processamentos para gerar o v√≠deo final.

    Par√¢metros:
        Nenhum: dados da montagem s√£o recebidos via formul√°rio multipart.

    Retorna:
        flask.Response: JSON com caminho do arquivo final ou mensagem de erro.
    """
    try:
        # üì• Par√¢metros recebidos
        escopo = request.form.get("escopo", "all")
        idx_str = request.form.get("idx", "")
        idx = int(idx_str) - 1 if idx_str.isdigit() else 0
        transicoes = json.loads(request.form.get("transicoes", "[]"))

        usar_trilha = request.form.get("usar_trilha") == "true"
        trilha_file = request.files.get("trilha")
        volume_pct = int(request.form.get("volume_trilha", 100))
        volume = max(0.0, min(volume_pct / 100.0, 1.0))

        usar_marca = request.form.get("usar_marca") == "true"
        marca_file = request.files.get("marca")
        opacidade_pct = int(request.form.get("opacidade_marca", 100))
        opacidade = max(0.0, min(opacidade_pct / 100.0, 1.0))

        # üìÅ Pastas?

        os.makedirs(path["videos_final"], exist_ok=True)

        # üé¨ Arquivos a unir
        if escopo == "single":
            arquivos = [os.path.join(path["videos_cenas"], f"video{idx + 1}.mp4")]
        else:
            arquivos = sorted([
                os.path.join(path["videos_cenas"], f) for f in os.listdir(path["videos_cenas"])
                if f.startswith("video") and f.endswith(".mp4")
            ], key=lambda x: int(re.search(r'video(\d+)', x).group(1)))

        print("üé¨ Cenas encontradas:", arquivos)

        # üß© Etapa 1: Unir cenas com transi√ß√µes
        # üìÑ Nome do v√≠deo final vindo do txt
        try:
            with open("ultimo_nome_video.txt", encoding="utf-8") as f:
                nome_video=f.read().strip()
            nome_arquivo=f"{nome_video}.mp4"
        except Exception:
            nome_arquivo="video_final.mp4"  # fallback
            print("‚ö†Ô∏è N√£o foi poss√≠vel ler o nome do v√≠deo, usando padr√£o.")

        output_path=os.path.join(path["videos_final"], nome_arquivo)

        unir_cenas_com_transicoes(arquivos, transicoes, output_path)

        # üîä Etapa 2: Adicionar trilha sonora (com volume)
        if usar_trilha and trilha_file:
            trilha_path = os.path.join(path["videos_final"], secure_filename(trilha_file.filename))
            trilha_file.save(trilha_path)
            adicionar_trilha_sonora(output_path, trilha_path, output_path, volume)

        # üñºÔ∏è Etapa 3: Adicionar marca d‚Äô√°gua (com opacidade)
        if usar_marca and marca_file:
            marca_path = os.path.join(path["videos_final"], secure_filename(marca_file.filename))
            marca_file.save(marca_path)
            adicionar_marca_dagua(output_path, marca_path, output_path, opacidade)

        # üßπ Etapa 4: Limpar tempor√°rios (_step_X.mp4)
        for f in os.listdir(path["videos_final"]):
            if "_step_" in f and f.endswith(".mp4"):
                os.remove(os.path.join(path["videos_final"], f))

        return jsonify({
            "status": "ok",
            "output": output_path,
            "nome_arquivo": nome_arquivo
        })

    except Exception as e:
        print("‚ùå Erro ao finalizar v√≠deo:", e)
        return jsonify({
            "status": "ok",
            "output": output_path,
            "nome_arquivo": nome_arquivo
        })


@app.route("/preview_audio_trilha", methods=["POST"])
def preview_audio_trilha():
    """Gera uma pr√©via mixada entre a narra√ß√£o e a trilha enviada.

    Par√¢metros:
        Nenhum: arquivos e configura√ß√µes s√£o recebidos via formul√°rio.

    Retorna:
        flask.Response: Arquivo de √°udio resultante ou mensagem de erro.
    """

    try:
        trilha_file = request.files.get("trilha")
        volume_pct = int(request.form.get("volume", 25))
        volume = max(0.0, min(volume_pct / 100.0, 1.0))

        base = get_config("pasta_salvar") or os.getcwd()
        audio1_path = os.path.abspath(os.path.join(path["audios"], "narracao1.mp3"))
        if not trilha_file or not os.path.exists(audio1_path):
            return "Arquivo ausente", 400

        trilha_temp = os.path.abspath(os.path.join(path["base"], "trilha_temp.mp3"))
        trilha_file.save(trilha_temp)
        output = os.path.abspath(os.path.join(path["base"], "preview_mix.m4a"))

        subprocess.run([
            "ffmpeg", "-y",
            "-i", audio1_path,
            "-i", trilha_temp,
            "-filter_complex",
            f"[1:a]volume={volume}[trilha];[0:a][trilha]amix=inputs=2:duration=first[a]",
            "-map", "[a]", "-c:a", "aac", "-b:a", "192k", output
        ], check=True)

        return send_file(output, mimetype="audio/mp4")

    except Exception as e:
        print("‚ùå Erro no preview:", e)
        return "Erro ao gerar preview", 500


@app.route('/preview_video/<int:idx>')
def preview_video(idx):
    """Disponibiliza o v√≠deo de uma cena espec√≠fica para pr√©-visualiza√ß√£o.

    Par√¢metros:
        idx (int): √çndice da cena cujo v√≠deo deve ser exibido.

    Retorna:
        flask.Response: Arquivo de v√≠deo MP4 ou erro caso n√£o exista.
    """
    #base      = get_config("pasta_salvar") or "default"
    video_path = os.path.join(path["base"], "videos_cenas", f"video{idx+1}.mp4")
    if not os.path.isfile(video_path):
        return "V√≠deo n√£o encontrado", 404
    return send_file(video_path, mimetype='video/mp4')

@app.route('/modules/videos_cenas/<path:filename>')
def serve_videos_cenas(filename):
    """Serve arquivos de v√≠deo intermedi√°rios gerados para cada cena.

    Par√¢metros:
        filename (str): Nome do arquivo localizado na pasta de v√≠deos de cenas.

    Retorna:
        flask.Response: Resposta de envio do arquivo requisitado.
    """
    return send_from_directory(
        os.path.join(app.root_path, 'modules', 'videos_cenas'),
        filename
    )

@app.route("/video_final/<nome>")
def servir_video_final(nome):
    """Entrega o arquivo final de v√≠deo montado para download.

    Par√¢metros:
        nome (str): Nome do arquivo gerado na pasta de v√≠deos finais.

    Retorna:
        flask.Response: Resposta com o arquivo solicitado.
    """
    return send_from_directory(path["videos_final"], nome)


#--------------------------------------------------------------------------------------------------------------------



#----- CONFIGURA√á√ïES ------------------------------------------------------------------------------------------------

@app.route("/configuracoes")
def pagina_configuracoes():
    """Renderiza a p√°gina de configura√ß√µes gerais do aplicativo.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: Template HTML com o formul√°rio de configura√ß√µes.
    """
    return render_template("configuracoes.html", page_title="Configura√ß√µes")

# caminho para o JSON gerado em etapas anteriores
def caminho_cenas_final():
    """Obt√©m o caminho completo para o arquivo de cenas com imagens.

    Par√¢metros:
        Nenhum.

    Retorna:
        str: Caminho absoluto do arquivo ``cenas_com_imagens.json``.
    """
    return os.path.join(get_config("pasta_salvar") or ".", "cenas_com_imagens.json")

def salvar_arquivo_upload(request_file, destino):
    """Salva um arquivo enviado pelo usu√°rio no destino informado.

    Par√¢metros:
        request_file (werkzeug.datastructures.FileStorage): Arquivo recebido da requisi√ß√£o.
        destino (str): Caminho onde o arquivo deve ser persistido.

    Retorna:
        str | None: Caminho final do arquivo salvo ou ``None`` se n√£o houver envio.
    """
    if request_file:
        os.makedirs(os.path.dirname(destino), exist_ok=True)
        request_file.save(destino)
        return destino
    return None

@app.route("/api/configuracoes", methods=["GET"])
def obter_configuracoes():
    """Consulta as configura√ß√µes persistidas para o usu√°rio atual.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: JSON com as chaves de configura√ß√£o relevantes.
    """
    return jsonify({
        "api_key": get_config("api_key"),
        "eleven_email": get_config("eleven_email"),
        "eleven_senha": get_config("eleven_senha"),
        "pasta_salvar": get_config("pasta_salvar")
    })

@app.route("/salvar_config", methods=["POST"])
def salvar_configuracoes():
    """Persiste as configura√ß√µes enviadas e prepara a estrutura de trabalho.

    Par√¢metros:
        Nenhum: os dados s√£o fornecidos pelo corpo JSON da requisi√ß√£o.

    Retorna:
        flask.Response: JSON indicando sucesso ou mensagem de erro.
    """
    dados = request.get_json()

    try:
        # Salva a configura√ß√£o criptografada
        salvar_config(dados)
        app.config['USUARIO_CONFIG'] = dados  # Atualiza config em tempo real
        print("üîê Configura√ß√µes gravadas com sucesso.")

        # Verifica se foi fornecido o caminho da pasta de salvamento
        pasta_salvar = dados.get("pasta_salvar")
        if pasta_salvar:
            # Garante subpastas de trabalho
            subpastas = [
                "imagens",
                "audios_narracoes",
                "legendas_ass",
                "legendas_srt",
                "videos_cenas",
                "videos_final"
            ]
            for nome in subpastas:
                caminho = os.path.join(pasta_salvar, nome)
                os.makedirs(caminho, exist_ok=True)
            print("üìÅ Subpastas criadas/verificadas.")

            # Agora garantimos os arquivos JSON iniciais

            # üîπ Atualiza o path global
            global path
            path = get_paths()

            os.makedirs(os.path.dirname(path["cenas"]), exist_ok=True)
            os.makedirs(os.path.dirname(path["cenas_com_imagens"]), exist_ok=True)

            if not os.path.exists(path["cenas"]):
                with open(path["cenas"], "w", encoding="utf-8") as f:
                    json.dump([], f, ensure_ascii=False, indent=2)
                print("üìù cenas.json criado.")

            if not os.path.exists(path["cenas_com_imagens"]):
                with open(path["cenas_com_imagens"], "w", encoding="utf-8") as f:
                    json.dump([], f, ensure_ascii=False, indent=2)
                print("üìù cenas_com_imagens.json criado.")

            # Opcional: criar ultimo_nome_video.txt com valor inicial
            if not os.path.exists(path["nome_video"]):
                with open(path["nome_video"], "w", encoding="utf-8") as f:
                    f.write("video1")
                print("üÜï ultimo_nome_video.txt criado com valor 'video1'.")

        else:
            print("‚ö†Ô∏è Nenhum caminho de pasta_salvar fornecido.")

        return jsonify({"status": "ok"})

    except Exception as e:
        print("‚ùå Erro ao salvar configura√ß√µes:", e)
        return jsonify({"status": "erro", "mensagem": str(e)}), 500



@app.route('/selecionar_pasta')
def selecionar_pasta():
    """Abre um di√°logo do sistema para sele√ß√£o da pasta de salvamento.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response: JSON contendo o caminho escolhido ou ``None``.
    """
    try:
        root = tk.Tk()
        root.withdraw()
        root.attributes("-topmost", True)
        pasta = filedialog.askdirectory(title="Escolha a pasta de salvamento")
        root.destroy()

        if pasta:
            return jsonify({"pasta": pasta})
        else:
            return jsonify({"pasta": None})

    except Exception as e:
        return jsonify({"error": str(e), "pasta": None})

def limpar_pastas_saida():
    """Remove arquivos tempor√°rios das principais pastas de sa√≠da.

    Par√¢metros:
        Nenhum.

    Retorna:
        None: A limpeza √© executada diretamente nas pastas configuradas.
    """
    pasta_base = get_config("pasta_salvar") or os.getcwd()
    subpastas = ["audios_narracoes", "imagens", "legendas_ass", "legendas_srt"]

    for subpasta in subpastas:
        pasta = os.path.join(pasta_base, subpasta)
        if os.path.exists(pasta):
            for arquivo in os.listdir(pasta):
                caminho = os.path.join(pasta, arquivo)
                if os.path.isfile(caminho):
                    os.remove(caminho)

@app.before_request
def checar_configuracao():
    """Garante que a pasta de salvamento esteja configurada antes das rotas protegidas.

    Par√¢metros:
        Nenhum.

    Retorna:
        flask.Response | None: Redireciona para a p√°gina de configura√ß√µes se necess√°rio.
    """
    caminho = request.path

    # Lista de rotas que n√£o precisam da config (evita loop)
    rotas_livres = ["/api/configuracoes", "/selecionar_pasta", "/configuracoes", "/salvar_config", "/static/", "/favicon.ico"]

    # Permitir se a rota est√° liberada
    if any(caminho.startswith(r) for r in rotas_livres):
        return

    # Verifica se a pasta de salvamento foi configurada
    pasta = get_config("pasta_salvar")

    if not pasta or not os.path.exists(pasta):
        print("üîí Redirecionando: configura√ß√£o n√£o encontrada ou pasta inv√°lida")
        return redirect(url_for("pagina_configuracoes"))  # Use o nome correto da view

# As rotas a seguir utilizam recursos de licen√ßa

@app.route("/upload_config_licenciada", methods=["POST"])
def upload_config_licenciada():
    """Processa o upload de um arquivo de licen√ßa criptografado.

    Par√¢metros:
        Nenhum: arquivo e dados s√£o recebidos no corpo multipart.

    Retorna:
        flask.Response: JSON com o status da importa√ß√£o.
    """
    print("üîÅ Recebendo upload de config_licenciado.json")

    if "arquivo" not in request.files:
        print("‚ùå Nenhum arquivo foi recebido.")
        return jsonify({"status": "erro", "mensagem": "Arquivo ausente."})

    arquivo = request.files["arquivo"]
    print("üìÅ Nome do arquivo recebido:", arquivo.filename)

    if not arquivo.filename.endswith(".json") and not arquivo.filename.endswith(".txt"):
        return jsonify({"status": "erro", "mensagem": "Formato inv√°lido."})

    try:
        conteudo = arquivo.read()
        fernet = carregar_fernet()
        dados = fernet.decrypt(conteudo).decode()
        novo_config = json.loads(dados)

        print("üîì Arquivo descriptografado com sucesso:", novo_config)

        # Carrega ou inicializa a configura√ß√£o atual
        caminho_destino = os.path.join("configuracoes", "config_licenciado.json")
        if os.path.exists(caminho_destino):
            atual = carregar_config_licenciada()
        else:
            atual = {
                "hardware_id": novo_config["hardware_id"],
                "creditos": 0,
                "api_key": ""
            }

        # Verifica se pertence √† mesma m√°quina
        if novo_config.get("hardware_id") != atual.get("hardware_id"):
            return jsonify({"status": "erro", "mensagem": "Arquivo n√£o pertence a este computador."})

        # Soma os cr√©ditos e atualiza API key
        creditos_novos = novo_config.get("creditos", 0)
        atual["creditos"] += creditos_novos

        if "api_key" in novo_config:
            atual["api_key"] = novo_config["api_key"]

        print("üíæ Salvando config licenciada atualizada:", atual)
        salvar_config_licenciada(atual)

        # Agora sim salva o original criptografado se n√£o existia
        if not os.path.exists(caminho_destino):
            os.makedirs("configuracoes", exist_ok=True)
            with open(caminho_destino, "wb") as f:
                f.write(conteudo)
            print("üÜï Arquivo original criptografado salvo.")

        return jsonify({"status": "ok", "mensagem": f"{creditos_novos} cr√©ditos adicionados com sucesso."})

    except Exception as e:
        print("‚ùå Erro ao processar upload:", e)
        return jsonify({"status": "erro", "mensagem": str(e)})

